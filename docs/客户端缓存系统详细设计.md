# 叶语APP客户端缓存系统详细设计

## 🎯 客户端缓存系统目标

### 核心目标
- **离线支持**: 用户在无网络时仍可查看历史消息和进行基本操作
- **性能优化**: 减少网络请求，提高响应速度
- **数据同步**: 保证客户端缓存与服务器数据的一致性
- **存储管理**: 智能管理缓存空间，自动清理过期数据

### 缓存策略
- **多级缓存**: 内存缓存 → IndexedDB → localStorage → 服务器
- **智能预加载**: 预测用户行为，提前加载可能需要的数据
- **增量同步**: 只同步变更的数据，减少网络传输
- **离线队列**: 离线时缓存用户操作，上线后自动同步

## 📊 客户端缓存架构设计

### 三层缓存架构
```typescript
interface CacheArchitecture {
  // L1: 内存缓存 (最快访问)
  memoryCache: {
    currentChatMessages: Map<string, Message[]>    // 当前聊天消息
    chatList: Chat[]                               // 聊天列表
    userProfiles: Map<string, UserProfile>        // 用户资料
    unreadCounts: Map<string, number>              // 未读计数
    onlineStatus: Map<string, boolean>             // 在线状态
  }
  
  // L2: IndexedDB缓存 (持久化结构数据)
  indexedDBCache: {
    cachedMessages: MessageCache[]                 // 消息缓存
    cachedChats: ChatCache[]                       // 聊天缓存
    cachedUsers: UserCache[]                       // 用户缓存
    syncStatus: SyncStatusCache[]                  // 同步状态
    offlineQueue: OfflineOperation[]               // 离线操作队列
  }
  
  // L3: localStorage缓存 (配置和状态)
  localStorageCache: {
    userSettings: UserSettings                     // 用户设置
    appConfig: AppConfig                           // 应用配置
    authTokens: AuthTokens                         // 认证令牌
    lastSyncTime: number                           // 最后同步时间
  }
}
```

### 缓存数据结构设计

#### 1. 消息缓存结构
```typescript
interface MessageCache {
  id: string                    // 消息ID
  chatId: string               // 聊天ID
  content: string              // 消息内容
  type: MessageType            // 消息类型
  timestamp: number            // 时间戳
  senderId: string             // 发送者ID
  status: MessageStatus        // 消息状态
  
  // 缓存元数据
  cachedAt: number             // 缓存时间
  lastAccessed: number         // 最后访问时间
  accessCount: number          // 访问次数
  syncStatus: 'synced' | 'pending' | 'failed'  // 同步状态
  
  // 媒体文件缓存信息
  mediaCache?: {
    localPath: string          // 本地文件路径
    downloadStatus: 'pending' | 'downloading' | 'completed' | 'failed'
    fileSize: number           // 文件大小
    downloadProgress: number   // 下载进度
  }
}
```

#### 2. 聊天缓存结构
```typescript
interface ChatCache {
  id: string                   // 聊天ID
  name: string                 // 聊天名称
  avatar: string               // 头像
  lastMessage: string          // 最后消息
  lastMessageTime: number      // 最后消息时间
  unreadCount: number          // 未读数
  
  // 缓存策略
  cacheLevel: 'hot' | 'warm' | 'cold'  // 缓存级别
  messagesCached: number       // 已缓存消息数
  maxCacheMessages: number     // 最大缓存消息数
  
  // 同步信息
  lastSyncTime: number         // 最后同步时间
  syncVersion: number          // 同步版本号
  
  // 用户设置
  isPinned: boolean           // 是否置顶
  isMuted: boolean            // 是否免打扰
  customSettings: any         // 自定义设置
}
```

#### 3. 用户缓存结构
```typescript
interface UserCache {
  id: string                   // 用户ID
  nickname: string             // 昵称
  avatar: string               // 头像
  isOnline: boolean           // 在线状态
  lastSeen: number            // 最后在线时间
  
  // 缓存策略
  cacheExpiry: number         // 缓存过期时间
  cacheLevel: 'frequent' | 'normal' | 'rare'  // 缓存级别
  
  // 关系信息
  isFriend: boolean           // 是否好友
  isBlocked: boolean          // 是否拉黑
  remarkName?: string         // 备注名
}
```

## 🔧 缓存管理器实现

### 核心缓存管理器
```typescript
export class ClientCacheManager {
  private memoryCache: MemoryCache
  private indexedDBCache: IndexedDBCache
  private localStorageCache: LocalStorageCache
  private syncManager: SyncManager
  
  constructor() {
    this.memoryCache = new MemoryCache()
    this.indexedDBCache = new IndexedDBCache()
    this.localStorageCache = new LocalStorageCache()
    this.syncManager = new SyncManager()
  }
  
  async initialize(): Promise<void> {
    await Promise.all([
      this.indexedDBCache.initialize(),
      this.memoryCache.initialize(),
      this.localStorageCache.initialize()
    ])
    
    // 启动后台任务
    this.startBackgroundTasks()
  }
  
  // 消息缓存操作
  async cacheMessage(message: Message): Promise<void> {
    // L1: 内存缓存
    this.memoryCache.setMessage(message)
    
    // L2: IndexedDB缓存
    const messageCache: MessageCache = {
      ...message,
      cachedAt: Date.now(),
      lastAccessed: Date.now(),
      accessCount: 1,
      syncStatus: 'synced'
    }
    await this.indexedDBCache.saveMessage(messageCache)
    
    // 更新聊天缓存
    await this.updateChatCache(message.chatId, message)
  }
  
  async getMessage(messageId: string): Promise<Message | null> {
    // L1: 内存缓存
    let message = this.memoryCache.getMessage(messageId)
    if (message) {
      return message
    }
    
    // L2: IndexedDB缓存
    const cachedMessage = await this.indexedDBCache.getMessage(messageId)
    if (cachedMessage && !this.isCacheExpired(cachedMessage)) {
      // 更新访问信息
      await this.updateAccessInfo(messageId)
      
      // 加载到内存缓存
      this.memoryCache.setMessage(cachedMessage)
      return cachedMessage
    }
    
    // L3: 从服务器获取
    try {
      message = await this.fetchFromServer(messageId)
      if (message) {
        await this.cacheMessage(message)
        return message
      }
    } catch (error) {
      console.error('从服务器获取消息失败:', error)
    }
    
    return null
  }
  
  // 聊天消息批量缓存
  async cacheChatMessages(chatId: string, messages: Message[]): Promise<void> {
    // 批量缓存到内存
    this.memoryCache.setChatMessages(chatId, messages)
    
    // 批量缓存到IndexedDB
    const messageCaches = messages.map(msg => ({
      ...msg,
      cachedAt: Date.now(),
      lastAccessed: Date.now(),
      accessCount: 1,
      syncStatus: 'synced' as const
    }))
    
    await this.indexedDBCache.batchSaveMessages(messageCaches)
    
    // 更新聊天缓存
    if (messages.length > 0) {
      const lastMessage = messages[messages.length - 1]
      await this.updateChatCache(chatId, lastMessage)
    }
  }
  
  async getChatMessages(chatId: string, page: number = 1, limit: number = 20): Promise<Message[]> {
    // L1: 内存缓存
    const memoryMessages = this.memoryCache.getChatMessages(chatId)
    if (memoryMessages && memoryMessages.length >= limit && page === 1) {
      return memoryMessages.slice(0, limit)
    }
    
    // L2: IndexedDB缓存
    const cachedMessages = await this.indexedDBCache.getChatMessages(chatId, page, limit)
    if (cachedMessages.length > 0) {
      // 加载到内存缓存
      if (page === 1) {
        this.memoryCache.setChatMessages(chatId, cachedMessages)
      }
      return cachedMessages
    }
    
    // L3: 从服务器获取
    try {
      const serverMessages = await this.fetchChatMessagesFromServer(chatId, page, limit)
      if (serverMessages.length > 0) {
        await this.cacheChatMessages(chatId, serverMessages)
        return serverMessages
      }
    } catch (error) {
      console.error('从服务器获取聊天消息失败:', error)
    }
    
    return []
  }
  
  // 聊天列表缓存
  async cacheChats(chats: Chat[]): Promise<void> {
    // 内存缓存
    this.memoryCache.setChats(chats)
    
    // IndexedDB缓存
    const chatCaches = chats.map(chat => ({
      ...chat,
      cacheLevel: this.determineCacheLevel(chat),
      messagesCached: 0,
      maxCacheMessages: this.getMaxCacheMessages(chat),
      lastSyncTime: Date.now(),
      syncVersion: 1
    }))
    
    await this.indexedDBCache.batchSaveChats(chatCaches)
  }
  
  async getChats(): Promise<Chat[]> {
    // L1: 内存缓存
    const memoryChats = this.memoryCache.getChats()
    if (memoryChats && memoryChats.length > 0) {
      return memoryChats
    }
    
    // L2: IndexedDB缓存
    const cachedChats = await this.indexedDBCache.getChats()
    if (cachedChats.length > 0) {
      this.memoryCache.setChats(cachedChats)
      return cachedChats
    }
    
    // L3: 从服务器获取
    try {
      const serverChats = await this.fetchChatsFromServer()
      if (serverChats.length > 0) {
        await this.cacheChats(serverChats)
        return serverChats
      }
    } catch (error) {
      console.error('从服务器获取聊天列表失败:', error)
    }
    
    return []
  }
  
  // 用户信息缓存
  async cacheUser(user: UserProfile): Promise<void> {
    const userCache: UserCache = {
      ...user,
      cacheExpiry: Date.now() + this.getUserCacheExpiry(user),
      cacheLevel: this.determineUserCacheLevel(user),
      isFriend: false,
      isBlocked: false
    }
    
    this.memoryCache.setUser(user)
    await this.indexedDBCache.saveUser(userCache)
  }
  
  async getUser(userId: string): Promise<UserProfile | null> {
    // L1: 内存缓存
    let user = this.memoryCache.getUser(userId)
    if (user) {
      return user
    }
    
    // L2: IndexedDB缓存
    const cachedUser = await this.indexedDBCache.getUser(userId)
    if (cachedUser && !this.isUserCacheExpired(cachedUser)) {
      this.memoryCache.setUser(cachedUser)
      return cachedUser
    }
    
    // L3: 从服务器获取
    try {
      user = await this.fetchUserFromServer(userId)
      if (user) {
        await this.cacheUser(user)
        return user
      }
    } catch (error) {
      console.error('从服务器获取用户信息失败:', error)
    }
    
    return null
  }
  
  // 离线操作队列
  async addOfflineOperation(operation: OfflineOperation): Promise<void> {
    await this.indexedDBCache.addOfflineOperation(operation)
  }
  
  async processOfflineOperations(): Promise<void> {
    const operations = await this.indexedDBCache.getOfflineOperations()
    
    for (const operation of operations) {
      try {
        await this.executeOperation(operation)
        await this.indexedDBCache.removeOfflineOperation(operation.id)
      } catch (error) {
        console.error('执行离线操作失败:', operation, error)
        // 增加重试次数
        operation.retryCount = (operation.retryCount || 0) + 1
        if (operation.retryCount >= 3) {
          // 超过重试次数，标记为失败
          operation.status = 'failed'
          await this.indexedDBCache.updateOfflineOperation(operation)
        }
      }
    }
  }
  
  // 缓存清理
  async cleanupCache(): Promise<void> {
    // 清理过期的消息缓存
    await this.cleanupExpiredMessages()
    
    // 清理过期的用户缓存
    await this.cleanupExpiredUsers()
    
    // 清理内存缓存
    this.memoryCache.cleanup()
    
    // 压缩IndexedDB
    await this.indexedDBCache.compact()
  }
  
  private async cleanupExpiredMessages(): Promise<void> {
    const now = Date.now()
    const textMessageExpiry = now - 365 * 24 * 60 * 60 * 1000  // 1年
    const mediaMessageExpiry = now - 7 * 24 * 60 * 60 * 1000   // 7天
    
    // 清理过期文本消息
    await this.indexedDBCache.deleteExpiredMessages('text', textMessageExpiry)
    
    // 清理过期媒体消息
    const mediaTypes = ['image', 'voice', 'video', 'file']
    for (const type of mediaTypes) {
      await this.indexedDBCache.deleteExpiredMessages(type, mediaMessageExpiry)
    }
  }
  
  private async cleanupExpiredUsers(): Promise<void> {
    const expiredUsers = await this.indexedDBCache.getExpiredUsers()
    for (const user of expiredUsers) {
      await this.indexedDBCache.deleteUser(user.id)
      this.memoryCache.removeUser(user.id)
    }
  }
  
  // 后台任务
  private startBackgroundTasks(): void {
    // 定期清理缓存
    setInterval(() => {
      this.cleanupCache()
    }, 60 * 60 * 1000) // 每小时清理一次
    
    // 定期处理离线操作
    setInterval(() => {
      this.processOfflineOperations()
    }, 30 * 1000) // 每30秒处理一次
    
    // 定期同步数据
    setInterval(() => {
      this.syncManager.incrementalSync()
    }, 5 * 60 * 1000) // 每5分钟同步一次
  }
  
  // 辅助方法
  private determineCacheLevel(chat: Chat): 'hot' | 'warm' | 'cold' {
    const now = Date.now()
    const daysSinceLastMessage = (now - chat.lastMessageTime) / (24 * 60 * 60 * 1000)
    
    if (daysSinceLastMessage < 1) return 'hot'
    if (daysSinceLastMessage < 7) return 'warm'
    return 'cold'
  }
  
  private getMaxCacheMessages(chat: Chat): number {
    const level = this.determineCacheLevel(chat)
    switch (level) {
      case 'hot': return 200
      case 'warm': return 100
      case 'cold': return 50
      default: return 50
    }
  }
  
  private determineUserCacheLevel(user: UserProfile): 'frequent' | 'normal' | 'rare' {
    // 根据用户交互频率确定缓存级别
    return 'normal' // 简化实现
  }
  
  private getUserCacheExpiry(user: UserProfile): number {
    const level = this.determineUserCacheLevel(user)
    switch (level) {
      case 'frequent': return 24 * 60 * 60 * 1000  // 24小时
      case 'normal': return 6 * 60 * 60 * 1000     // 6小时
      case 'rare': return 1 * 60 * 60 * 1000       // 1小时
      default: return 1 * 60 * 60 * 1000
    }
  }
  
  private isCacheExpired(cache: MessageCache): boolean {
    const now = Date.now()
    const maxAge = cache.type === 'text' ? 
      365 * 24 * 60 * 60 * 1000 :  // 文本消息1年
      7 * 24 * 60 * 60 * 1000      // 媒体消息7天
    
    return (now - cache.cachedAt) > maxAge
  }
  
  private isUserCacheExpired(cache: UserCache): boolean {
    return Date.now() > cache.cacheExpiry
  }
}
```

## 🔄 数据同步机制

### 增量同步管理器
```typescript
export class SyncManager {
  private cacheManager: ClientCacheManager
  private apiClient: APIClient
  
  constructor(cacheManager: ClientCacheManager, apiClient: APIClient) {
    this.cacheManager = cacheManager
    this.apiClient = apiClient
  }
  
  // 增量同步
  async incrementalSync(): Promise<void> {
    const lastSyncTime = await this.getLastSyncTime()
    
    try {
      // 同步消息
      await this.syncMessages(lastSyncTime)
      
      // 同步聊天列表
      await this.syncChats(lastSyncTime)
      
      // 同步用户状态
      await this.syncUserStatus(lastSyncTime)
      
      // 更新同步时间
      await this.updateLastSyncTime(Date.now())
      
    } catch (error) {
      console.error('增量同步失败:', error)
    }
  }
  
  private async syncMessages(since: number): Promise<void> {
    const response = await this.apiClient.get('/messages/sync', {
      params: { since, limit: 100 }
    })
    
    for (const messageData of response.data.messages) {
      await this.cacheManager.cacheMessage(messageData)
    }
  }
  
  private async syncChats(since: number): Promise<void> {
    const response = await this.apiClient.get('/chats/sync', {
      params: { since }
    })
    
    await this.cacheManager.cacheChats(response.data.chats)
  }
  
  private async syncUserStatus(since: number): Promise<void> {
    const response = await this.apiClient.get('/users/status/sync', {
      params: { since }
    })
    
    for (const userData of response.data.users) {
      await this.cacheManager.cacheUser(userData)
    }
  }
}
```

这个客户端缓存系统设计提供了完整的缓存管理功能，包括多级缓存、智能清理、离线支持和数据同步。
