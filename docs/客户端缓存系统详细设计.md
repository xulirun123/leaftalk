# å¶è¯­APPå®¢æˆ·ç«¯ç¼“å­˜ç³»ç»Ÿè¯¦ç»†è®¾è®¡

## ğŸ¯ å®¢æˆ·ç«¯ç¼“å­˜ç³»ç»Ÿç›®æ ‡

### æ ¸å¿ƒç›®æ ‡
- **ç¦»çº¿æ”¯æŒ**: ç”¨æˆ·åœ¨æ— ç½‘ç»œæ—¶ä»å¯æŸ¥çœ‹å†å²æ¶ˆæ¯å’Œè¿›è¡ŒåŸºæœ¬æ“ä½œ
- **æ€§èƒ½ä¼˜åŒ–**: å‡å°‘ç½‘ç»œè¯·æ±‚ï¼Œæé«˜å“åº”é€Ÿåº¦
- **æ•°æ®åŒæ­¥**: ä¿è¯å®¢æˆ·ç«¯ç¼“å­˜ä¸æœåŠ¡å™¨æ•°æ®çš„ä¸€è‡´æ€§
- **å­˜å‚¨ç®¡ç†**: æ™ºèƒ½ç®¡ç†ç¼“å­˜ç©ºé—´ï¼Œè‡ªåŠ¨æ¸…ç†è¿‡æœŸæ•°æ®

### ç¼“å­˜ç­–ç•¥
- **å¤šçº§ç¼“å­˜**: å†…å­˜ç¼“å­˜ â†’ IndexedDB â†’ localStorage â†’ æœåŠ¡å™¨
- **æ™ºèƒ½é¢„åŠ è½½**: é¢„æµ‹ç”¨æˆ·è¡Œä¸ºï¼Œæå‰åŠ è½½å¯èƒ½éœ€è¦çš„æ•°æ®
- **å¢é‡åŒæ­¥**: åªåŒæ­¥å˜æ›´çš„æ•°æ®ï¼Œå‡å°‘ç½‘ç»œä¼ è¾“
- **ç¦»çº¿é˜Ÿåˆ—**: ç¦»çº¿æ—¶ç¼“å­˜ç”¨æˆ·æ“ä½œï¼Œä¸Šçº¿åè‡ªåŠ¨åŒæ­¥

## ğŸ“Š å®¢æˆ·ç«¯ç¼“å­˜æ¶æ„è®¾è®¡

### ä¸‰å±‚ç¼“å­˜æ¶æ„
```typescript
interface CacheArchitecture {
  // L1: å†…å­˜ç¼“å­˜ (æœ€å¿«è®¿é—®)
  memoryCache: {
    currentChatMessages: Map<string, Message[]>    // å½“å‰èŠå¤©æ¶ˆæ¯
    chatList: Chat[]                               // èŠå¤©åˆ—è¡¨
    userProfiles: Map<string, UserProfile>        // ç”¨æˆ·èµ„æ–™
    unreadCounts: Map<string, number>              // æœªè¯»è®¡æ•°
    onlineStatus: Map<string, boolean>             // åœ¨çº¿çŠ¶æ€
  }
  
  // L2: IndexedDBç¼“å­˜ (æŒä¹…åŒ–ç»“æ„æ•°æ®)
  indexedDBCache: {
    cachedMessages: MessageCache[]                 // æ¶ˆæ¯ç¼“å­˜
    cachedChats: ChatCache[]                       // èŠå¤©ç¼“å­˜
    cachedUsers: UserCache[]                       // ç”¨æˆ·ç¼“å­˜
    syncStatus: SyncStatusCache[]                  // åŒæ­¥çŠ¶æ€
    offlineQueue: OfflineOperation[]               // ç¦»çº¿æ“ä½œé˜Ÿåˆ—
  }
  
  // L3: localStorageç¼“å­˜ (é…ç½®å’ŒçŠ¶æ€)
  localStorageCache: {
    userSettings: UserSettings                     // ç”¨æˆ·è®¾ç½®
    appConfig: AppConfig                           // åº”ç”¨é…ç½®
    authTokens: AuthTokens                         // è®¤è¯ä»¤ç‰Œ
    lastSyncTime: number                           // æœ€ååŒæ­¥æ—¶é—´
  }
}
```

### ç¼“å­˜æ•°æ®ç»“æ„è®¾è®¡

#### 1. æ¶ˆæ¯ç¼“å­˜ç»“æ„
```typescript
interface MessageCache {
  id: string                    // æ¶ˆæ¯ID
  chatId: string               // èŠå¤©ID
  content: string              // æ¶ˆæ¯å†…å®¹
  type: MessageType            // æ¶ˆæ¯ç±»å‹
  timestamp: number            // æ—¶é—´æˆ³
  senderId: string             // å‘é€è€…ID
  status: MessageStatus        // æ¶ˆæ¯çŠ¶æ€
  
  // ç¼“å­˜å…ƒæ•°æ®
  cachedAt: number             // ç¼“å­˜æ—¶é—´
  lastAccessed: number         // æœ€åè®¿é—®æ—¶é—´
  accessCount: number          // è®¿é—®æ¬¡æ•°
  syncStatus: 'synced' | 'pending' | 'failed'  // åŒæ­¥çŠ¶æ€
  
  // åª’ä½“æ–‡ä»¶ç¼“å­˜ä¿¡æ¯
  mediaCache?: {
    localPath: string          // æœ¬åœ°æ–‡ä»¶è·¯å¾„
    downloadStatus: 'pending' | 'downloading' | 'completed' | 'failed'
    fileSize: number           // æ–‡ä»¶å¤§å°
    downloadProgress: number   // ä¸‹è½½è¿›åº¦
  }
}
```

#### 2. èŠå¤©ç¼“å­˜ç»“æ„
```typescript
interface ChatCache {
  id: string                   // èŠå¤©ID
  name: string                 // èŠå¤©åç§°
  avatar: string               // å¤´åƒ
  lastMessage: string          // æœ€åæ¶ˆæ¯
  lastMessageTime: number      // æœ€åæ¶ˆæ¯æ—¶é—´
  unreadCount: number          // æœªè¯»æ•°
  
  // ç¼“å­˜ç­–ç•¥
  cacheLevel: 'hot' | 'warm' | 'cold'  // ç¼“å­˜çº§åˆ«
  messagesCached: number       // å·²ç¼“å­˜æ¶ˆæ¯æ•°
  maxCacheMessages: number     // æœ€å¤§ç¼“å­˜æ¶ˆæ¯æ•°
  
  // åŒæ­¥ä¿¡æ¯
  lastSyncTime: number         // æœ€ååŒæ­¥æ—¶é—´
  syncVersion: number          // åŒæ­¥ç‰ˆæœ¬å·
  
  // ç”¨æˆ·è®¾ç½®
  isPinned: boolean           // æ˜¯å¦ç½®é¡¶
  isMuted: boolean            // æ˜¯å¦å…æ‰“æ‰°
  customSettings: any         // è‡ªå®šä¹‰è®¾ç½®
}
```

#### 3. ç”¨æˆ·ç¼“å­˜ç»“æ„
```typescript
interface UserCache {
  id: string                   // ç”¨æˆ·ID
  nickname: string             // æ˜µç§°
  avatar: string               // å¤´åƒ
  isOnline: boolean           // åœ¨çº¿çŠ¶æ€
  lastSeen: number            // æœ€ååœ¨çº¿æ—¶é—´
  
  // ç¼“å­˜ç­–ç•¥
  cacheExpiry: number         // ç¼“å­˜è¿‡æœŸæ—¶é—´
  cacheLevel: 'frequent' | 'normal' | 'rare'  // ç¼“å­˜çº§åˆ«
  
  // å…³ç³»ä¿¡æ¯
  isFriend: boolean           // æ˜¯å¦å¥½å‹
  isBlocked: boolean          // æ˜¯å¦æ‹‰é»‘
  remarkName?: string         // å¤‡æ³¨å
}
```

## ğŸ”§ ç¼“å­˜ç®¡ç†å™¨å®ç°

### æ ¸å¿ƒç¼“å­˜ç®¡ç†å™¨
```typescript
export class ClientCacheManager {
  private memoryCache: MemoryCache
  private indexedDBCache: IndexedDBCache
  private localStorageCache: LocalStorageCache
  private syncManager: SyncManager
  
  constructor() {
    this.memoryCache = new MemoryCache()
    this.indexedDBCache = new IndexedDBCache()
    this.localStorageCache = new LocalStorageCache()
    this.syncManager = new SyncManager()
  }
  
  async initialize(): Promise<void> {
    await Promise.all([
      this.indexedDBCache.initialize(),
      this.memoryCache.initialize(),
      this.localStorageCache.initialize()
    ])
    
    // å¯åŠ¨åå°ä»»åŠ¡
    this.startBackgroundTasks()
  }
  
  // æ¶ˆæ¯ç¼“å­˜æ“ä½œ
  async cacheMessage(message: Message): Promise<void> {
    // L1: å†…å­˜ç¼“å­˜
    this.memoryCache.setMessage(message)
    
    // L2: IndexedDBç¼“å­˜
    const messageCache: MessageCache = {
      ...message,
      cachedAt: Date.now(),
      lastAccessed: Date.now(),
      accessCount: 1,
      syncStatus: 'synced'
    }
    await this.indexedDBCache.saveMessage(messageCache)
    
    // æ›´æ–°èŠå¤©ç¼“å­˜
    await this.updateChatCache(message.chatId, message)
  }
  
  async getMessage(messageId: string): Promise<Message | null> {
    // L1: å†…å­˜ç¼“å­˜
    let message = this.memoryCache.getMessage(messageId)
    if (message) {
      return message
    }
    
    // L2: IndexedDBç¼“å­˜
    const cachedMessage = await this.indexedDBCache.getMessage(messageId)
    if (cachedMessage && !this.isCacheExpired(cachedMessage)) {
      // æ›´æ–°è®¿é—®ä¿¡æ¯
      await this.updateAccessInfo(messageId)
      
      // åŠ è½½åˆ°å†…å­˜ç¼“å­˜
      this.memoryCache.setMessage(cachedMessage)
      return cachedMessage
    }
    
    // L3: ä»æœåŠ¡å™¨è·å–
    try {
      message = await this.fetchFromServer(messageId)
      if (message) {
        await this.cacheMessage(message)
        return message
      }
    } catch (error) {
      console.error('ä»æœåŠ¡å™¨è·å–æ¶ˆæ¯å¤±è´¥:', error)
    }
    
    return null
  }
  
  // èŠå¤©æ¶ˆæ¯æ‰¹é‡ç¼“å­˜
  async cacheChatMessages(chatId: string, messages: Message[]): Promise<void> {
    // æ‰¹é‡ç¼“å­˜åˆ°å†…å­˜
    this.memoryCache.setChatMessages(chatId, messages)
    
    // æ‰¹é‡ç¼“å­˜åˆ°IndexedDB
    const messageCaches = messages.map(msg => ({
      ...msg,
      cachedAt: Date.now(),
      lastAccessed: Date.now(),
      accessCount: 1,
      syncStatus: 'synced' as const
    }))
    
    await this.indexedDBCache.batchSaveMessages(messageCaches)
    
    // æ›´æ–°èŠå¤©ç¼“å­˜
    if (messages.length > 0) {
      const lastMessage = messages[messages.length - 1]
      await this.updateChatCache(chatId, lastMessage)
    }
  }
  
  async getChatMessages(chatId: string, page: number = 1, limit: number = 20): Promise<Message[]> {
    // L1: å†…å­˜ç¼“å­˜
    const memoryMessages = this.memoryCache.getChatMessages(chatId)
    if (memoryMessages && memoryMessages.length >= limit && page === 1) {
      return memoryMessages.slice(0, limit)
    }
    
    // L2: IndexedDBç¼“å­˜
    const cachedMessages = await this.indexedDBCache.getChatMessages(chatId, page, limit)
    if (cachedMessages.length > 0) {
      // åŠ è½½åˆ°å†…å­˜ç¼“å­˜
      if (page === 1) {
        this.memoryCache.setChatMessages(chatId, cachedMessages)
      }
      return cachedMessages
    }
    
    // L3: ä»æœåŠ¡å™¨è·å–
    try {
      const serverMessages = await this.fetchChatMessagesFromServer(chatId, page, limit)
      if (serverMessages.length > 0) {
        await this.cacheChatMessages(chatId, serverMessages)
        return serverMessages
      }
    } catch (error) {
      console.error('ä»æœåŠ¡å™¨è·å–èŠå¤©æ¶ˆæ¯å¤±è´¥:', error)
    }
    
    return []
  }
  
  // èŠå¤©åˆ—è¡¨ç¼“å­˜
  async cacheChats(chats: Chat[]): Promise<void> {
    // å†…å­˜ç¼“å­˜
    this.memoryCache.setChats(chats)
    
    // IndexedDBç¼“å­˜
    const chatCaches = chats.map(chat => ({
      ...chat,
      cacheLevel: this.determineCacheLevel(chat),
      messagesCached: 0,
      maxCacheMessages: this.getMaxCacheMessages(chat),
      lastSyncTime: Date.now(),
      syncVersion: 1
    }))
    
    await this.indexedDBCache.batchSaveChats(chatCaches)
  }
  
  async getChats(): Promise<Chat[]> {
    // L1: å†…å­˜ç¼“å­˜
    const memoryChats = this.memoryCache.getChats()
    if (memoryChats && memoryChats.length > 0) {
      return memoryChats
    }
    
    // L2: IndexedDBç¼“å­˜
    const cachedChats = await this.indexedDBCache.getChats()
    if (cachedChats.length > 0) {
      this.memoryCache.setChats(cachedChats)
      return cachedChats
    }
    
    // L3: ä»æœåŠ¡å™¨è·å–
    try {
      const serverChats = await this.fetchChatsFromServer()
      if (serverChats.length > 0) {
        await this.cacheChats(serverChats)
        return serverChats
      }
    } catch (error) {
      console.error('ä»æœåŠ¡å™¨è·å–èŠå¤©åˆ—è¡¨å¤±è´¥:', error)
    }
    
    return []
  }
  
  // ç”¨æˆ·ä¿¡æ¯ç¼“å­˜
  async cacheUser(user: UserProfile): Promise<void> {
    const userCache: UserCache = {
      ...user,
      cacheExpiry: Date.now() + this.getUserCacheExpiry(user),
      cacheLevel: this.determineUserCacheLevel(user),
      isFriend: false,
      isBlocked: false
    }
    
    this.memoryCache.setUser(user)
    await this.indexedDBCache.saveUser(userCache)
  }
  
  async getUser(userId: string): Promise<UserProfile | null> {
    // L1: å†…å­˜ç¼“å­˜
    let user = this.memoryCache.getUser(userId)
    if (user) {
      return user
    }
    
    // L2: IndexedDBç¼“å­˜
    const cachedUser = await this.indexedDBCache.getUser(userId)
    if (cachedUser && !this.isUserCacheExpired(cachedUser)) {
      this.memoryCache.setUser(cachedUser)
      return cachedUser
    }
    
    // L3: ä»æœåŠ¡å™¨è·å–
    try {
      user = await this.fetchUserFromServer(userId)
      if (user) {
        await this.cacheUser(user)
        return user
      }
    } catch (error) {
      console.error('ä»æœåŠ¡å™¨è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', error)
    }
    
    return null
  }
  
  // ç¦»çº¿æ“ä½œé˜Ÿåˆ—
  async addOfflineOperation(operation: OfflineOperation): Promise<void> {
    await this.indexedDBCache.addOfflineOperation(operation)
  }
  
  async processOfflineOperations(): Promise<void> {
    const operations = await this.indexedDBCache.getOfflineOperations()
    
    for (const operation of operations) {
      try {
        await this.executeOperation(operation)
        await this.indexedDBCache.removeOfflineOperation(operation.id)
      } catch (error) {
        console.error('æ‰§è¡Œç¦»çº¿æ“ä½œå¤±è´¥:', operation, error)
        // å¢åŠ é‡è¯•æ¬¡æ•°
        operation.retryCount = (operation.retryCount || 0) + 1
        if (operation.retryCount >= 3) {
          // è¶…è¿‡é‡è¯•æ¬¡æ•°ï¼Œæ ‡è®°ä¸ºå¤±è´¥
          operation.status = 'failed'
          await this.indexedDBCache.updateOfflineOperation(operation)
        }
      }
    }
  }
  
  // ç¼“å­˜æ¸…ç†
  async cleanupCache(): Promise<void> {
    // æ¸…ç†è¿‡æœŸçš„æ¶ˆæ¯ç¼“å­˜
    await this.cleanupExpiredMessages()
    
    // æ¸…ç†è¿‡æœŸçš„ç”¨æˆ·ç¼“å­˜
    await this.cleanupExpiredUsers()
    
    // æ¸…ç†å†…å­˜ç¼“å­˜
    this.memoryCache.cleanup()
    
    // å‹ç¼©IndexedDB
    await this.indexedDBCache.compact()
  }
  
  private async cleanupExpiredMessages(): Promise<void> {
    const now = Date.now()
    const textMessageExpiry = now - 365 * 24 * 60 * 60 * 1000  // 1å¹´
    const mediaMessageExpiry = now - 7 * 24 * 60 * 60 * 1000   // 7å¤©
    
    // æ¸…ç†è¿‡æœŸæ–‡æœ¬æ¶ˆæ¯
    await this.indexedDBCache.deleteExpiredMessages('text', textMessageExpiry)
    
    // æ¸…ç†è¿‡æœŸåª’ä½“æ¶ˆæ¯
    const mediaTypes = ['image', 'voice', 'video', 'file']
    for (const type of mediaTypes) {
      await this.indexedDBCache.deleteExpiredMessages(type, mediaMessageExpiry)
    }
  }
  
  private async cleanupExpiredUsers(): Promise<void> {
    const expiredUsers = await this.indexedDBCache.getExpiredUsers()
    for (const user of expiredUsers) {
      await this.indexedDBCache.deleteUser(user.id)
      this.memoryCache.removeUser(user.id)
    }
  }
  
  // åå°ä»»åŠ¡
  private startBackgroundTasks(): void {
    // å®šæœŸæ¸…ç†ç¼“å­˜
    setInterval(() => {
      this.cleanupCache()
    }, 60 * 60 * 1000) // æ¯å°æ—¶æ¸…ç†ä¸€æ¬¡
    
    // å®šæœŸå¤„ç†ç¦»çº¿æ“ä½œ
    setInterval(() => {
      this.processOfflineOperations()
    }, 30 * 1000) // æ¯30ç§’å¤„ç†ä¸€æ¬¡
    
    // å®šæœŸåŒæ­¥æ•°æ®
    setInterval(() => {
      this.syncManager.incrementalSync()
    }, 5 * 60 * 1000) // æ¯5åˆ†é’ŸåŒæ­¥ä¸€æ¬¡
  }
  
  // è¾…åŠ©æ–¹æ³•
  private determineCacheLevel(chat: Chat): 'hot' | 'warm' | 'cold' {
    const now = Date.now()
    const daysSinceLastMessage = (now - chat.lastMessageTime) / (24 * 60 * 60 * 1000)
    
    if (daysSinceLastMessage < 1) return 'hot'
    if (daysSinceLastMessage < 7) return 'warm'
    return 'cold'
  }
  
  private getMaxCacheMessages(chat: Chat): number {
    const level = this.determineCacheLevel(chat)
    switch (level) {
      case 'hot': return 200
      case 'warm': return 100
      case 'cold': return 50
      default: return 50
    }
  }
  
  private determineUserCacheLevel(user: UserProfile): 'frequent' | 'normal' | 'rare' {
    // æ ¹æ®ç”¨æˆ·äº¤äº’é¢‘ç‡ç¡®å®šç¼“å­˜çº§åˆ«
    return 'normal' // ç®€åŒ–å®ç°
  }
  
  private getUserCacheExpiry(user: UserProfile): number {
    const level = this.determineUserCacheLevel(user)
    switch (level) {
      case 'frequent': return 24 * 60 * 60 * 1000  // 24å°æ—¶
      case 'normal': return 6 * 60 * 60 * 1000     // 6å°æ—¶
      case 'rare': return 1 * 60 * 60 * 1000       // 1å°æ—¶
      default: return 1 * 60 * 60 * 1000
    }
  }
  
  private isCacheExpired(cache: MessageCache): boolean {
    const now = Date.now()
    const maxAge = cache.type === 'text' ? 
      365 * 24 * 60 * 60 * 1000 :  // æ–‡æœ¬æ¶ˆæ¯1å¹´
      7 * 24 * 60 * 60 * 1000      // åª’ä½“æ¶ˆæ¯7å¤©
    
    return (now - cache.cachedAt) > maxAge
  }
  
  private isUserCacheExpired(cache: UserCache): boolean {
    return Date.now() > cache.cacheExpiry
  }
}
```

## ğŸ”„ æ•°æ®åŒæ­¥æœºåˆ¶

### å¢é‡åŒæ­¥ç®¡ç†å™¨
```typescript
export class SyncManager {
  private cacheManager: ClientCacheManager
  private apiClient: APIClient
  
  constructor(cacheManager: ClientCacheManager, apiClient: APIClient) {
    this.cacheManager = cacheManager
    this.apiClient = apiClient
  }
  
  // å¢é‡åŒæ­¥
  async incrementalSync(): Promise<void> {
    const lastSyncTime = await this.getLastSyncTime()
    
    try {
      // åŒæ­¥æ¶ˆæ¯
      await this.syncMessages(lastSyncTime)
      
      // åŒæ­¥èŠå¤©åˆ—è¡¨
      await this.syncChats(lastSyncTime)
      
      // åŒæ­¥ç”¨æˆ·çŠ¶æ€
      await this.syncUserStatus(lastSyncTime)
      
      // æ›´æ–°åŒæ­¥æ—¶é—´
      await this.updateLastSyncTime(Date.now())
      
    } catch (error) {
      console.error('å¢é‡åŒæ­¥å¤±è´¥:', error)
    }
  }
  
  private async syncMessages(since: number): Promise<void> {
    const response = await this.apiClient.get('/messages/sync', {
      params: { since, limit: 100 }
    })
    
    for (const messageData of response.data.messages) {
      await this.cacheManager.cacheMessage(messageData)
    }
  }
  
  private async syncChats(since: number): Promise<void> {
    const response = await this.apiClient.get('/chats/sync', {
      params: { since }
    })
    
    await this.cacheManager.cacheChats(response.data.chats)
  }
  
  private async syncUserStatus(since: number): Promise<void> {
    const response = await this.apiClient.get('/users/status/sync', {
      params: { since }
    })
    
    for (const userData of response.data.users) {
      await this.cacheManager.cacheUser(userData)
    }
  }
}
```

è¿™ä¸ªå®¢æˆ·ç«¯ç¼“å­˜ç³»ç»Ÿè®¾è®¡æä¾›äº†å®Œæ•´çš„ç¼“å­˜ç®¡ç†åŠŸèƒ½ï¼ŒåŒ…æ‹¬å¤šçº§ç¼“å­˜ã€æ™ºèƒ½æ¸…ç†ã€ç¦»çº¿æ”¯æŒå’Œæ•°æ®åŒæ­¥ã€‚
