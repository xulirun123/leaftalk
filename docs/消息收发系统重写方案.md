# 叶语消息收发系统重写方案 v2.0

## 🎯 设计目标

- **简单清晰**：单一数据源，统一管理
- **实时准确**：消息实时收发，无重复
- **错误处理**：发送失败重试，黑名单拒收
- **数据安全**：分类存储，用户可控删除
- **隐私保护**：注销清理，换设备不可恢复

## 📊 核心数据结构

### 消息数据结构
```typescript
interface Message {
  id: string                    // 唯一ID：msg_时间戳_随机数
  chatId: string               // 聊天ID（对方用户ID）
  senderId: string             // 发送者ID
  receiverId: string           // 接收者ID
  content: string              // 消息内容
  type: 'text' | 'image' | 'voice' | 'video' | 'file' | 'redpacket' | 'transfer'
  timestamp: number            // 发送时间戳
  status: 'sending' | 'sent' | 'delivered' | 'read' | 'failed'
  isSelf: boolean             // 是否自己发送
  retryCount?: number         // 重试次数
  isDeleted?: boolean         // 是否已删除（软删除）

  // 媒体文件相关字段
  fileUrl?: string            // 服务器文件URL
  localPath?: string          // 本地文件路径
  fileSize?: number           // 文件大小（字节）
  duration?: number           // 语音/视频时长（秒）
  thumbnail?: string          // 缩略图（图片/视频）
  fileName?: string           // 原始文件名
  mimeType?: string           // 文件MIME类型

  // 红包/转账相关字段
  amount?: number             // 金额
  redpacketId?: string        // 红包ID
  transferId?: string         // 转账ID
  paymentStatus?: 'pending' | 'completed' | 'expired' | 'refunded'
}
```

### 聊天数据结构
```typescript
interface Chat {
  id: string                  // 聊天ID（对方用户ID）
  userId: string              // 对方用户ID
  name: string                // 对方姓名
  avatar: string              // 对方头像
  lastMessage: string         // 最后一条消息内容
  lastMessageTime: number     // 最后消息时间
  unreadCount: number         // 未读消息数
  isPinned: boolean          // 是否置顶
  isMuted: boolean           // 是否免打扰
  isDeleted: boolean         // 是否已删除聊天项
  createdAt: number          // 聊天创建时间
}
```

### 数据存储策略
```typescript
interface StoragePolicy {
  // 客户端存储时长
  clientStorage: {
    textMessages: number      // 文本消息：1年
    mediaMessages: number     // 媒体消息：7天
    redpacketTransfer: 'permanent'  // 红包转账：永久
  }

  // 服务器存储时长
  serverStorage: {
    messageRecords: number    // 消息记录：1年
    mediaFiles: number        // 媒体文件：1个月
    redpacketTransfer: 'permanent'  // 红包转账：永久
  }

  // 用户操作影响
  userActions: {
    deleteChatItem: 'clearLocal'     // 删除聊天项：清理本地
    accountDeletion: 'clearAll'      // 注销账号：清理所有（保留族谱）
    deviceChange: 'noRestore'        // 换设备：不可恢复
  }
}
```

## 🏗️ 系统架构

### 单一Store架构
```
messageStore.ts (唯一消息管理中心)
├── 消息状态管理
├── 聊天列表管理  
├── 未读计数管理
├── 实时服务集成
└── 本地存储管理
```

### 核心组件
- `messageStore.ts` - 唯一消息管理Store
- `ChatList.vue` - 聊天列表组件
- `ChatPage.vue` - 聊天页面组件
- `MessageInput.vue` - 消息输入组件

## 🔄 核心算法逻辑

### 1. 消息发送流程
```
用户输入消息 → 立即显示(status: sending) → HTTP API发送 → 实时推送给接收者
                                                ↓                ↓
                                        成功: sent          接收者实时收到
                                                ↓                ↓
                                        失败: failed        离线则服务器暂存
                                                ↓
                                        自动重试(最多3次)
```

### 2. 实时消息接收流程
```
统一实时服务推送 → 检查黑名单 → 消息去重 → 添加到Store → 更新聊天列表
                      ↓              ↓           ↓            ↓
                  拒收则忽略      基于ID去重    保存本地     更新未读数
```

### 3. 离线消息处理流程
```
用户离线时 → 服务器暂存消息 → 用户上线 → 服务器推送离线消息 → 客户端接收处理
              ↓                    ↓              ↓              ↓
          消息已保存            检测到连接        批量推送        去重后显示
                                                                    ↓
                                                            更新未读计数和最后消息
```

### 4. 未读消息计数更新流程
```
在线状态：
接收新消息 → 检查当前聊天页面 → 是当前聊天：不增加未读 | 非当前聊天：+1未读
                                    ↓                        ↓
                              立即标记已读              更新聊天列表未读数
                                                            ↓
                                                    更新底部导航总未读数

离线状态：
服务器收到消息 → 暂存消息 → 记录未读计数 → 用户上线 → 推送离线消息 → 更新本地未读计数
```

### 5. 最后一条消息更新流程
```
在线状态：
发送/接收消息 → 立即更新聊天项最后消息 → 重新排序聊天列表 → 保存到本地存储

离线状态：
服务器收到消息 → 更新服务器端聊天记录 → 用户上线 → 推送最新聊天状态 → 更新本地聊天列表
```

### 4. 消息去重算法
```typescript
// 基于消息ID和时间戳的双重去重
const isDuplicate = (newMessage: Message) => {
  return messages.value.some(msg =>
    msg.id === newMessage.id ||
    (msg.senderId === newMessage.senderId &&
     msg.content === newMessage.content &&
     Math.abs(msg.timestamp - newMessage.timestamp) < 1000)
  )
}
```

### 5. 黑名单处理算法
```typescript
// 接收消息时检查黑名单
const shouldRejectMessage = (senderId: string) => {
  const blacklistStore = useBlacklistStore()
  if (blacklistStore.isBlocked(senderId)) {
    console.log('🚫 拒收黑名单用户消息:', senderId)
    return true
  }
  return false
}
```

### 6. 聊天项删除处理
```typescript
// 删除聊天项时清理本地数据
const deleteChatItem = async (chatId: string) => {
  // 1. 标记聊天为已删除
  const chat = chats.value.find(c => c.id === chatId)
  if (chat) {
    chat.isDeleted = true
  }

  // 2. 清理本地消息
  await messageStorage.clearChatMessages(chatId)

  // 3. 清理媒体缓存
  await mediaFileManager.clearChatMedia(chatId)

  // 4. 从聊天列表移除
  chats.value = chats.value.filter(c => c.id !== chatId)

  // 5. 不影响服务器数据
  console.log('✅ 聊天项已删除，本地数据已清理')
}
```

### 7. 用户注销数据清理
```typescript
// 用户注销时的数据清理策略
const handleAccountDeletion = async (userId: string) => {
  // 服务器端清理（API调用）
  await api.delete('/user/chat-data', {
    data: {
      userId,
      clearChatMessages: true,      // 清理聊天消息
      clearRedpacketTransfer: true, // 清理红包转账记录
      preserveGenealogy: true       // 保留族谱数据
    }
  })

  // 客户端清理
  await messageStorage.clearAllData()
  await mediaFileManager.clearAllCache()

  console.log('✅ 用户数据已清理，族谱数据已保留')
}
```

## 📱 用户界面逻辑

### 聊天列表显示逻辑
```typescript
// 排序：置顶 > 时间倒序
const sortedChats = computed(() => {
  return chats.value.sort((a, b) => {
    if (a.isPinned && !b.isPinned) return -1
    if (!a.isPinned && b.isPinned) return 1
    return b.lastMessageTime - a.lastMessageTime
  })
})
```

### 未读计数显示逻辑
```typescript
// 总未读数：所有聊天未读数之和
const totalUnreadCount = computed(() => {
  return chats.value.reduce((total, chat) => {
    return total + (chat.isMuted ? 0 : chat.unreadCount)
  }, 0)
})
```

### 消息状态显示逻辑
```typescript
// 消息状态图标
const getStatusIcon = (status: string) => {
  switch (status) {
    case 'sending': return '⏳'
    case 'sent': return '✓'
    case 'delivered': return '✓✓'
    case 'read': return '✓✓' // 蓝色
    case 'failed': return '❌'
  }
}
```

## 🔧 技术实现要点

### 1. 统一实时服务集成
```typescript
// 使用现有的统一实时服务，不修改服务器
const initRealtime = () => {
  const realtimeService = window.unifiedRealtimeService
  realtimeService.subscribe('chat', 'new_message', handleNewMessage)
}
```

### 2. 本地存储策略
```typescript
// 移动端优化存储：IndexedDB + 内存缓存
class MessageStorage {
  private db: IDBDatabase | null = null
  private cache = new Map<string, Message[]>()

  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('YeYuMessages', 1)

      request.onerror = () => reject(request.error)
      request.onsuccess = () => {
        this.db = request.result
        resolve(this.db)
      }

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result

        // 创建消息表
        if (!db.objectStoreNames.contains('messages')) {
          const store = db.createObjectStore('messages', { keyPath: 'id' })
          store.createIndex('chatId', 'chatId', { unique: false })
          store.createIndex('timestamp', 'timestamp', { unique: false })
        }

        // 创建聊天表
        if (!db.objectStoreNames.contains('chats')) {
          db.createObjectStore('chats', { keyPath: 'id' })
        }
      }
    })
  }

  async saveMessages(chatId: string, messages: Message[]) {
    if (!this.db) await this.init()

    const transaction = this.db!.transaction(['messages'], 'readwrite')
    const store = transaction.objectStore('messages')

    // 批量保存消息
    for (const message of messages) {
      store.put(message)
    }

    // 更新内存缓存
    this.cache.set(chatId, messages)

    return new Promise((resolve, reject) => {
      transaction.oncomplete = () => resolve(true)
      transaction.onerror = () => reject(transaction.error)
    })
  }

  async loadMessages(chatId: string, limit = 50): Promise<Message[]> {
    // 先检查内存缓存
    if (this.cache.has(chatId)) {
      return this.cache.get(chatId)!
    }

    if (!this.db) await this.init()

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['messages'], 'readonly')
      const store = transaction.objectStore('messages')
      const index = store.index('chatId')
      const request = index.getAll(chatId)

      request.onsuccess = () => {
        const messages = request.result
          .sort((a, b) => a.timestamp - b.timestamp)
          .slice(-limit) // 只取最新的消息

        // 更新缓存
        this.cache.set(chatId, messages)
        resolve(messages)
      }

      request.onerror = () => reject(request.error)
    })
  }

  // 分类清理旧消息（保留红包转账记录）
  async cleanOldMessages() {
    const sevenDaysAgo = Date.now() - 7 * 24 * 60 * 60 * 1000
    const oneYearAgo = Date.now() - 365 * 24 * 60 * 60 * 1000

    const transaction = this.db!.transaction(['messages'], 'readwrite')
    const store = transaction.objectStore('messages')
    const index = store.index('timestamp')

    // 清理1年前的文本消息（保留红包转账）
    const textRange = IDBKeyRange.upperBound(oneYearAgo)
    index.openCursor(textRange).onsuccess = (event) => {
      const cursor = (event.target as IDBRequest).result
      if (cursor) {
        const message = cursor.value
        if (message.type === 'text' && !['redpacket', 'transfer'].includes(message.type)) {
          cursor.delete()
        }
        cursor.continue()
      }
    }

    // 清理7天前的媒体消息
    const mediaRange = IDBKeyRange.upperBound(sevenDaysAgo)
    index.openCursor(mediaRange).onsuccess = (event) => {
      const cursor = (event.target as IDBRequest).result
      if (cursor) {
        const message = cursor.value
        if (['image', 'voice', 'video', 'file'].includes(message.type)) {
          // 删除本地文件
          this.deleteLocalFile(message.localPath)
          // 删除消息记录
          cursor.delete()
        }
        cursor.continue()
      }
    }
  }

  // 清理指定聊天的所有消息（删除聊天项时调用）
  async clearChatMessages(chatId: string) {
    const transaction = this.db!.transaction(['messages'], 'readwrite')
    const store = transaction.objectStore('messages')
    const index = store.index('chatId')
    const request = index.openCursor(IDBKeyRange.only(chatId))

    request.onsuccess = (event) => {
      const cursor = (event.target as IDBRequest).result
      if (cursor) {
        const message = cursor.value
        // 删除本地媒体文件
        if (message.localPath) {
          this.deleteLocalFile(message.localPath)
        }
        // 删除消息记录
        cursor.delete()
        cursor.continue()
      }
    }

    // 清理内存缓存
    this.cache.delete(chatId)
  }

  // 清理所有数据（用户注销时调用）
  async clearAllData() {
    if (!this.db) return

    const transaction = this.db.transaction(['messages', 'chats'], 'readwrite')

    // 清理所有消息
    const messageStore = transaction.objectStore('messages')
    await messageStore.clear()

    // 清理所有聊天
    const chatStore = transaction.objectStore('chats')
    await chatStore.clear()

    // 清理内存缓存
    this.cache.clear()

    console.log('✅ 所有本地聊天数据已清理')
  }

  // 删除本地文件
  private async deleteLocalFile(filePath: string) {
    if (!filePath) return

    try {
      // 如果是Web环境，清理缓存
      if ('caches' in window) {
        const cache = await caches.open('yeyu-media')
        await cache.delete(filePath)
      }

      // 如果是Cordova/Capacitor环境，删除文件
      if (window.cordova?.file || window.Capacitor?.Plugins?.Filesystem) {
        // 具体实现根据使用的框架而定
        console.log('删除本地文件:', filePath)
      }
    } catch (error) {
      console.error('删除本地文件失败:', error)
    }
  }
}

const messageStorage = new MessageStorage()

// 媒体文件管理器
class MediaFileManager {
  private cacheStorage: Cache | null = null

  async init() {
    if ('caches' in window) {
      this.cacheStorage = await caches.open('yeyu-media-v1')
    }
  }

  // 下载并缓存媒体文件
  async downloadAndCache(fileUrl: string, messageId: string, chatId: string): Promise<string> {
    try {
      const response = await fetch(fileUrl)
      const blob = await response.blob()

      // 生成本地路径（包含chatId便于清理）
      const localPath = `media/${chatId}/${messageId}_${Date.now()}`

      // 缓存到CacheStorage
      if (this.cacheStorage) {
        await this.cacheStorage.put(localPath, new Response(blob))
      }

      return localPath
    } catch (error) {
      console.error('下载媒体文件失败:', error)
      throw error
    }
  }

  // 清理指定聊天的媒体文件
  async clearChatMedia(chatId: string): Promise<void> {
    if (!this.cacheStorage) return

    try {
      const keys = await this.cacheStorage.keys()
      const chatMediaKeys = keys.filter(request =>
        request.url.includes(`media/${chatId}/`)
      )

      for (const key of chatMediaKeys) {
        await this.cacheStorage.delete(key)
      }

      console.log(`✅ 已清理聊天 ${chatId} 的媒体文件`)
    } catch (error) {
      console.error('清理聊天媒体文件失败:', error)
    }
  }

  // 清理所有缓存（用户注销时调用）
  async clearAllCache(): Promise<boolean> {
    try {
      if ('caches' in window) {
        return await caches.delete('yeyu-media-v1')
      }
      return true
    } catch (error) {
      console.error('清理所有缓存失败:', error)
      return false
    }
  }

  // 获取本地缓存文件
  async getLocalFile(localPath: string): Promise<Blob | null> {
    if (!this.cacheStorage || !localPath) return null

    try {
      const response = await this.cacheStorage.match(localPath)
      return response ? await response.blob() : null
    } catch (error) {
      console.error('获取本地文件失败:', error)
      return null
    }
  }
}

const mediaFileManager = new MediaFileManager()
```

### 3. 错误处理策略
```typescript
// 统一错误处理
const handleError = (error: any, context: string) => {
  console.error(`[${context}] 错误:`, error)
  // 显示用户友好的错误提示
  showToast('消息发送失败，请重试')
}
```

## 📋 完整开发步骤

### 第一步：清理旧代码 (30分钟)
- 删除 `chatStore.ts`, `chat-new.ts`, `newChatStore.ts`, `chatStoreExample.ts`
- 删除 `NewChatPage.vue`, `ChatList-new.vue` 等重复组件
- 删除旧的 `chatApi.ts` 文件
- 清理无用的导入和引用

### 第二步：创建核心存储系统 (120分钟)
- 创建 `messageStore.ts` - 统一消息管理
- 实现 `MessageStorage` 类 - IndexedDB存储
- 实现 `MediaFileManager` 类 - 媒体文件管理
- 集成统一实时服务适配器
- 实现消息发送、接收、去重逻辑
- 实现黑名单检查机制
- 实现离线消息处理
- 实现分类数据清理策略

### 第三步：重写核心组件 (100分钟)
- 重写 `ChatList.vue` - 聊天列表显示
- 重写 `ChatPage.vue` - 聊天页面
- 创建 `MessageItem.vue` - 消息项组件
- 创建 `MessageInput.vue` - 消息输入组件
- 创建红包转账消息组件
- 实现聊天项删除功能

### 第四步：完善功能特性 (80分钟)
- 实现未读消息计数系统
- 实现消息状态显示（发送中、已发送、失败）
- 实现发送失败重试机制
- 实现媒体文件自动下载和缓存
- 实现聊天列表实时排序
- 集成底部导航栏未读计数显示

### 第五步：数据管理功能 (60分钟)
- 实现聊天项删除时的数据清理
- 实现用户注销时的数据清理API
- 实现自动清理过期消息
- 实现红包转账记录永久保存
- 测试换设备时数据不可恢复

### 第六步：全面测试优化 (50分钟)
- 实时消息收发测试
- 离线消息同步测试
- 黑名单拒收测试
- 消息去重测试
- 数据清理功能测试
- 性能优化和Bug修复

## 🎯 最终效果

1. **消息不重复**：基于ID和内容的双重去重机制
2. **实时性强**：发送立即显示，接收实时推送
3. **离线消息准确**：服务器暂存，上线后批量推送
4. **黑名单生效**：接收时检查，直接拒收
5. **错误处理完善**：自动重试3次，状态清晰显示
6. **未读计数准确**：实时更新，底部导航同步
7. **数据分类管理**：
   - 文本消息：客户端1年，服务器1年
   - 媒体消息：客户端7天，服务器1个月
   - 红包转账：永久保存
8. **用户数据控制**：
   - 删除聊天项：清理本地数据
   - 用户注销：清理所有数据（保留族谱）
   - 换设备：不可恢复历史数据
9. **代码架构清晰**：单一Store，统一管理

## 🔒 数据安全策略

### 隐私保护机制
```typescript
// 数据清理策略
const dataPrivacyPolicy = {
  // 聊天项删除
  deleteChatItem: {
    clientAction: 'clearLocalData',     // 清理本地数据
    serverAction: 'keepData',           // 服务器保留数据
    recoverable: false                  // 不可恢复
  },

  // 用户注销
  accountDeletion: {
    clientAction: 'clearAllData',       // 清理所有本地数据
    serverAction: 'clearChatData',      // 清理聊天相关数据
    preserveData: ['genealogy'],        // 保留族谱数据
    recoverable: false                  // 不可恢复
  },

  // 换设备登录
  deviceChange: {
    clientAction: 'noDataRestore',      // 不恢复历史数据
    serverAction: 'keepData',           // 服务器保留数据
    newDeviceAccess: 'newMessagesOnly'  // 只能接收新消息
  }
}
```

### 服务器数据管理
```typescript
// 服务器端数据清理API
const serverDataManagement = {
  // 自动清理过期数据
  autoCleanup: {
    textMessages: '1年后删除',
    mediaFiles: '1个月后删除',
    redpacketTransfer: '永久保留'
  },

  // 用户注销清理
  userDeletionCleanup: {
    chatMessages: '立即删除',
    redpacketTransfer: '立即删除',
    mediaFiles: '立即删除',
    genealogyData: '保留不删除'
  }
}
```

## 🔒 安全考虑

- 消息内容加密存储
- 黑名单实时生效
- 敏感信息过滤
- 防止消息重放攻击

## 📱 移动端存储方案对比

### localStorage的问题
- **容量限制**：通常只有5-10MB，消息多了容易超限
- **性能问题**：同步操作，大量数据会阻塞UI
- **清理风险**：系统清理缓存时可能丢失数据
- **隐私模式**：在隐私/无痕模式下不可用

### IndexedDB的优势
- **大容量**：通常可用空间为磁盘的50%，足够存储大量消息
- **异步操作**：不会阻塞UI线程
- **事务支持**：保证数据一致性
- **索引查询**：支持复杂查询，性能更好
- **持久化**：数据更安全，不易丢失

### 混合存储策略
```typescript
// 三层存储架构
class HybridStorage {
  // 第一层：内存缓存（最快，容量小）
  private memoryCache = new Map<string, Message[]>()

  // 第二层：IndexedDB（快速，容量大）
  private indexedDB: MessageStorage

  // 第三层：服务器（最慢，但最可靠）
  private apiClient: ApiClient

  async getMessage(chatId: string): Promise<Message[]> {
    // 1. 先查内存
    if (this.memoryCache.has(chatId)) {
      return this.memoryCache.get(chatId)!
    }

    // 2. 再查IndexedDB
    const messages = await this.indexedDB.loadMessages(chatId)
    if (messages.length > 0) {
      this.memoryCache.set(chatId, messages)
      return messages
    }

    // 3. 最后查服务器
    const serverMessages = await this.apiClient.getMessages(chatId)
    await this.indexedDB.saveMessages(chatId, serverMessages)
    this.memoryCache.set(chatId, serverMessages)
    return serverMessages
  }
}
```

## 💡 关键实现细节

### 消息发送失败处理
```typescript
// 发送失败的完整处理流程
const sendMessage = async (content: string, type: string, receiverId: string) => {
  const message: Message = {
    id: generateMessageId(),
    chatId: receiverId,
    senderId: currentUserId,
    receiverId,
    content,
    type,
    timestamp: Date.now(),
    status: 'sending',
    isSelf: true,
    retryCount: 0
  }

  // 1. 立即显示消息
  addMessageToUI(message)

  // 2. 发送到服务器
  try {
    await sendToAPI(message)
    updateMessageStatus(message.id, 'sent')
  } catch (error) {
    // 3. 发送失败，标记并重试
    updateMessageStatus(message.id, 'failed')
    scheduleRetry(message)
  }
}
```

### 黑名单拒收处理
```typescript
// 接收消息时的黑名单检查
const handleIncomingMessage = (messageData: any) => {
  // 1. 检查发送者是否在黑名单
  if (isBlocked(messageData.senderId)) {
    console.log('🚫 拒收黑名单用户消息:', messageData.senderId)
    return // 直接忽略，不做任何处理
  }

  // 2. 检查消息是否重复
  if (isDuplicate(messageData)) {
    console.log('🔄 忽略重复消息:', messageData.id)
    return
  }

  // 3. 正常处理消息
  const message = formatMessage(messageData)
  addMessage(message)
  updateChatList(message)
  incrementUnreadCount(message.chatId)
}
```

### 离线消息同步
```typescript
// 用户上线后同步离线消息
const syncOfflineMessages = async () => {
  try {
    const lastSyncTime = getLastSyncTime()
    const response = await api.get('/messages/offline', {
      params: { since: lastSyncTime }
    })

    response.data.messages.forEach(messageData => {
      handleIncomingMessage(messageData)
    })

    setLastSyncTime(Date.now())
  } catch (error) {
    console.error('离线消息同步失败:', error)
  }
}
```

## 🚀 性能优化策略

### 1. 消息分页加载
```typescript
// 按需加载历史消息，避免一次性加载过多
const loadMoreMessages = async (chatId: string) => {
  const currentMessages = getChatMessages(chatId)
  const oldestMessage = currentMessages[0]

  const response = await api.get(`/chats/${chatId}/messages`, {
    params: {
      before: oldestMessage?.timestamp,
      limit: 20
    }
  })

  prependMessages(chatId, response.data.messages)
}
```

### 2. 内存管理
```typescript
// 限制内存中的消息数量，超出部分存储到localStorage
const MAX_MESSAGES_IN_MEMORY = 100

const addMessage = (message: Message) => {
  const chatMessages = getChatMessages(message.chatId)
  chatMessages.push(message)

  // 如果消息过多，将旧消息移到localStorage
  if (chatMessages.length > MAX_MESSAGES_IN_MEMORY) {
    const oldMessages = chatMessages.splice(0, 20)
    saveToLocalStorage(message.chatId, oldMessages)
  }
}
```

### 3. 实时连接优化
```typescript
// 智能重连，避免频繁连接
const smartReconnect = () => {
  let reconnectAttempts = 0
  const maxAttempts = 5

  const reconnect = () => {
    if (reconnectAttempts >= maxAttempts) {
      console.log('达到最大重连次数，停止重连')
      return
    }

    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000)
    setTimeout(() => {
      reconnectAttempts++
      initRealtime()
    }, delay)
  }

  return reconnect
}
```
