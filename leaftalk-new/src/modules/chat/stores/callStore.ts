import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export interface CallParticipant {
  id: string
  name: string
  avatar: string
  isMuted: boolean
  isVideoEnabled: boolean
  isScreenSharing: boolean
  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'failed'
  stream?: MediaStream
}

export interface CallSession {
  id: string
  type: 'audio' | 'video' | 'screen'
  status: 'idle' | 'calling' | 'ringing' | 'connected' | 'ended' | 'failed'
  participants: CallParticipant[]
  startTime?: number
  endTime?: number
  duration: number
  isIncoming: boolean
  caller: CallParticipant
  receiver: CallParticipant
  quality: 'excellent' | 'good' | 'fair' | 'poor'
  networkStats: {
    bitrate: number
    packetLoss: number
    latency: number
  }
}

export interface CallSettings {
  audioEnabled: boolean
  videoEnabled: boolean
  microphoneId: string
  cameraId: string
  speakerId: string
  videoQuality: 'low' | 'medium' | 'high'
  audioQuality: 'low' | 'medium' | 'high'
  echoCancellation: boolean
  noiseSuppression: boolean
  autoGainControl: boolean
}

export const useCallStore = defineStore('call', () => {
  // Áä∂ÊÄÅ
  const currentCall = ref<CallSession | null>(null)
  const callHistory = ref<CallSession[]>([])
  const devices = ref<{
    microphones: MediaDeviceInfo[]
    cameras: MediaDeviceInfo[]
    speakers: MediaDeviceInfo[]
  }>({
    microphones: [],
    cameras: [],
    speakers: []
  })
  
  const settings = ref<CallSettings>({
    audioEnabled: true,
    videoEnabled: true,
    microphoneId: '',
    cameraId: '',
    speakerId: '',
    videoQuality: 'medium',
    audioQuality: 'high',
    echoCancellation: true,
    noiseSuppression: true,
    autoGainControl: true
  })

  const localStream = ref<MediaStream | null>(null)
  const remoteStream = ref<MediaStream | null>(null)
  const peerConnection = ref<RTCPeerConnection | null>(null)
  const isInitialized = ref(false)
  const error = ref<string | null>(null)

  // ËÆ°ÁÆóÂ±ûÊÄß
  const isInCall = computed(() => 
    currentCall.value && ['calling', 'ringing', 'connected'].includes(currentCall.value.status)
  )

  const callDuration = computed(() => {
    if (!currentCall.value?.startTime) return 0
    const now = currentCall.value.endTime || Date.now()
    return Math.floor((now - currentCall.value.startTime) / 1000)
  })

  const isAudioCall = computed(() => currentCall.value?.type === 'audio')
  const isVideoCall = computed(() => currentCall.value?.type === 'video')
  const isScreenShare = computed(() => currentCall.value?.type === 'screen')

  // WebRTCÈÖçÁΩÆ
  const rtcConfig: RTCConfiguration = {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      // ÂèØ‰ª•Ê∑ªÂä†TURNÊúçÂä°Âô®
      // {
      //   urls: 'turn:your-turn-server.com:3478',
      //   username: 'username',
      //   credential: 'password'
      // }
    ],
    iceCandidatePoolSize: 10
  }

  // ÂàùÂßãÂåñ
  const initialize = async () => {
    try {
      if (isInitialized.value) return

      // Ëé∑ÂèñËÆæÂ§áÂàóË°®
      await getDevices()
      
      // ËÆæÁΩÆÈªòËÆ§ËÆæÂ§á
      if (devices.value.microphones.length > 0 && !settings.value.microphoneId) {
        settings.value.microphoneId = devices.value.microphones[0].deviceId
      }
      if (devices.value.cameras.length > 0 && !settings.value.cameraId) {
        settings.value.cameraId = devices.value.cameras[0].deviceId
      }
      if (devices.value.speakers.length > 0 && !settings.value.speakerId) {
        settings.value.speakerId = devices.value.speakers[0].deviceId
      }

      isInitialized.value = true
      console.log('‚úÖ ÈÄöËØùÁ≥ªÁªüÂàùÂßãÂåñÂÆåÊàê')

    } catch (err) {
      console.error('‚ùå ÈÄöËØùÁ≥ªÁªüÂàùÂßãÂåñÂ§±Ë¥•:', err)
      error.value = err instanceof Error ? err.message : 'ÂàùÂßãÂåñÂ§±Ë¥•'
    }
  }

  // Ëé∑ÂèñËÆæÂ§áÂàóË°®
  const getDevices = async () => {
    try {
      const deviceList = await navigator.mediaDevices.enumerateDevices()
      
      devices.value.microphones = deviceList.filter(device => device.kind === 'audioinput')
      devices.value.cameras = deviceList.filter(device => device.kind === 'videoinput')
      devices.value.speakers = deviceList.filter(device => device.kind === 'audiooutput')

      console.log('üé§ Ê£ÄÊµãÂà∞ËÆæÂ§á:', {
        microphones: devices.value.microphones.length,
        cameras: devices.value.cameras.length,
        speakers: devices.value.speakers.length
      })

    } catch (err) {
      console.error('Ëé∑ÂèñËÆæÂ§áÂàóË°®Â§±Ë¥•:', err)
      throw err
    }
  }

  // Ëé∑ÂèñÂ™í‰ΩìÊµÅ
  const getMediaStream = async (constraints: MediaStreamConstraints) => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia(constraints)
      localStream.value = stream
      return stream

    } catch (err) {
      console.error('Ëé∑ÂèñÂ™í‰ΩìÊµÅÂ§±Ë¥•:', err)
      throw new Error('Êó†Ê≥ïËÆøÈóÆÊëÑÂÉèÂ§¥ÊàñÈ∫¶ÂÖãÈ£éÔºåËØ∑Ê£ÄÊü•ÊùÉÈôêËÆæÁΩÆ')
    }
  }

  // ÂàõÂª∫PeerConnection
  const createPeerConnection = () => {
    try {
      const pc = new RTCPeerConnection(rtcConfig)
      
      // ÁõëÂê¨ICEÂÄôÈÄâ
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          // ÂèëÈÄÅICEÂÄôÈÄâÂà∞ËøúÁ´Ø
          sendSignalingMessage({
            type: 'ice-candidate',
            candidate: event.candidate
          })
        }
      }

      // ÁõëÂê¨ËøúÁ´ØÊµÅ
      pc.ontrack = (event) => {
        console.log('üì∫ Êé•Êî∂Âà∞ËøúÁ´ØÊµÅ')
        remoteStream.value = event.streams[0]
      }

      // ÁõëÂê¨ËøûÊé•Áä∂ÊÄÅ
      pc.onconnectionstatechange = () => {
        console.log('üîó ËøûÊé•Áä∂ÊÄÅ:', pc.connectionState)
        updateConnectionStatus(pc.connectionState)
      }

      // ÁõëÂê¨ICEËøûÊé•Áä∂ÊÄÅ
      pc.oniceconnectionstatechange = () => {
        console.log('üßä ICEËøûÊé•Áä∂ÊÄÅ:', pc.iceConnectionState)
      }

      peerConnection.value = pc
      return pc

    } catch (err) {
      console.error('ÂàõÂª∫PeerConnectionÂ§±Ë¥•:', err)
      throw err
    }
  }

  // ÂèëËµ∑ÈÄöËØù
  const startCall = async (targetUserId: string, type: 'audio' | 'video' = 'audio') => {
    try {
      if (isInCall.value) {
        throw new Error('ÂΩìÂâçÂ∑≤Âú®ÈÄöËØù‰∏≠')
      }

      // ÂàõÂª∫ÈÄöËØù‰ºöËØù
      const callSession: CallSession = {
        id: `call_${Date.now()}`,
        type,
        status: 'calling',
        participants: [],
        isIncoming: false,
        caller: {
          id: 'current_user',
          name: 'Êàë',
          avatar: 'https://api.dicebear.com/7.x/avataaars/svg?seed=me',
          isMuted: false,
          isVideoEnabled: type === 'video',
          isScreenSharing: false,
          connectionStatus: 'connecting'
        },
        receiver: {
          id: targetUserId,
          name: 'ÂØπÊñπ',
          avatar: 'https://api.dicebear.com/7.x/avataaars/svg?seed=target',
          isMuted: false,
          isVideoEnabled: type === 'video',
          isScreenSharing: false,
          connectionStatus: 'connecting'
        },
        duration: 0,
        quality: 'good',
        networkStats: {
          bitrate: 0,
          packetLoss: 0,
          latency: 0
        }
      }

      currentCall.value = callSession

      // Ëé∑ÂèñÂ™í‰ΩìÊµÅ
      const constraints: MediaStreamConstraints = {
        audio: {
          deviceId: settings.value.microphoneId ? { exact: settings.value.microphoneId } : undefined,
          echoCancellation: settings.value.echoCancellation,
          noiseSuppression: settings.value.noiseSuppression,
          autoGainControl: settings.value.autoGainControl
        },
        video: type === 'video' ? {
          deviceId: settings.value.cameraId ? { exact: settings.value.cameraId } : undefined,
          width: { ideal: 1280 },
          height: { ideal: 720 },
          frameRate: { ideal: 30 }
        } : false
      }

      await getMediaStream(constraints)

      // ÂàõÂª∫PeerConnection
      const pc = createPeerConnection()

      // Ê∑ªÂä†Êú¨Âú∞ÊµÅ
      if (localStream.value) {
        localStream.value.getTracks().forEach(track => {
          pc.addTrack(track, localStream.value!)
        })
      }

      // ÂàõÂª∫Offer
      const offer = await pc.createOffer()
      await pc.setLocalDescription(offer)

      // ÂèëÈÄÅÈÄöËØùÈÇÄËØ∑
      await sendCallInvitation(targetUserId, {
        type: 'call-offer',
        callId: callSession.id,
        callType: type,
        offer: offer
      })

      console.log('üìû ÂèëËµ∑ÈÄöËØù:', type, 'ÁõÆÊ†áÁî®Êà∑:', targetUserId)

    } catch (err) {
      console.error('ÂèëËµ∑ÈÄöËØùÂ§±Ë¥•:', err)
      error.value = err instanceof Error ? err.message : 'ÂèëËµ∑ÈÄöËØùÂ§±Ë¥•'
      await endCall()
      throw err
    }
  }

  // Êé•Âê¨ÈÄöËØù
  const answerCall = async (callData: any) => {
    try {
      if (isInCall.value) {
        throw new Error('ÂΩìÂâçÂ∑≤Âú®ÈÄöËØù‰∏≠')
      }

      // Êõ¥Êñ∞ÈÄöËØùÁä∂ÊÄÅ
      if (currentCall.value) {
        currentCall.value.status = 'connected'
        currentCall.value.startTime = Date.now()
      }

      // Ëé∑ÂèñÂ™í‰ΩìÊµÅ
      const constraints: MediaStreamConstraints = {
        audio: {
          deviceId: settings.value.microphoneId ? { exact: settings.value.microphoneId } : undefined,
          echoCancellation: settings.value.echoCancellation,
          noiseSuppression: settings.value.noiseSuppression,
          autoGainControl: settings.value.autoGainControl
        },
        video: callData.callType === 'video' ? {
          deviceId: settings.value.cameraId ? { exact: settings.value.cameraId } : undefined,
          width: { ideal: 1280 },
          height: { ideal: 720 },
          frameRate: { ideal: 30 }
        } : false
      }

      await getMediaStream(constraints)

      // ÂàõÂª∫PeerConnection
      const pc = createPeerConnection()

      // Ê∑ªÂä†Êú¨Âú∞ÊµÅ
      if (localStream.value) {
        localStream.value.getTracks().forEach(track => {
          pc.addTrack(track, localStream.value!)
        })
      }

      // ËÆæÁΩÆËøúÁ´ØÊèèËø∞
      await pc.setRemoteDescription(callData.offer)

      // ÂàõÂª∫Answer
      const answer = await pc.createAnswer()
      await pc.setLocalDescription(answer)

      // ÂèëÈÄÅÂ∫îÁ≠î
      await sendSignalingMessage({
        type: 'call-answer',
        callId: callData.callId,
        answer: answer
      })

      console.log('‚úÖ Êé•Âê¨ÈÄöËØùÊàêÂäü')

    } catch (err) {
      console.error('Êé•Âê¨ÈÄöËØùÂ§±Ë¥•:', err)
      error.value = err instanceof Error ? err.message : 'Êé•Âê¨ÈÄöËØùÂ§±Ë¥•'
      await endCall()
      throw err
    }
  }

  // ÊãíÁªùÈÄöËØù
  const rejectCall = async (callId: string) => {
    try {
      await sendSignalingMessage({
        type: 'call-reject',
        callId: callId
      })

      if (currentCall.value) {
        currentCall.value.status = 'ended'
        currentCall.value.endTime = Date.now()
        addToHistory(currentCall.value)
        currentCall.value = null
      }

      await cleanup()
      console.log('‚ùå ÊãíÁªùÈÄöËØù')

    } catch (err) {
      console.error('ÊãíÁªùÈÄöËØùÂ§±Ë¥•:', err)
    }
  }

  // ÁªìÊùüÈÄöËØù
  const endCall = async () => {
    try {
      if (currentCall.value) {
        currentCall.value.status = 'ended'
        currentCall.value.endTime = Date.now()
        
        // ÂèëÈÄÅÁªìÊùüÈÄöËØù‰ø°Âè∑
        await sendSignalingMessage({
          type: 'call-end',
          callId: currentCall.value.id
        })

        addToHistory(currentCall.value)
        currentCall.value = null
      }

      await cleanup()
      console.log('üìû ÈÄöËØùÂ∑≤ÁªìÊùü')

    } catch (err) {
      console.error('ÁªìÊùüÈÄöËØùÂ§±Ë¥•:', err)
    }
  }

  // ÂàáÊç¢ÈùôÈü≥
  const toggleMute = () => {
    if (localStream.value) {
      const audioTrack = localStream.value.getAudioTracks()[0]
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled
        if (currentCall.value) {
          currentCall.value.caller.isMuted = !audioTrack.enabled
        }
        console.log('üé§ ÈùôÈü≥Áä∂ÊÄÅ:', !audioTrack.enabled)
      }
    }
  }

  // ÂàáÊç¢ËßÜÈ¢ë
  const toggleVideo = () => {
    if (localStream.value) {
      const videoTrack = localStream.value.getVideoTracks()[0]
      if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled
        if (currentCall.value) {
          currentCall.value.caller.isVideoEnabled = videoTrack.enabled
        }
        console.log('üìπ ËßÜÈ¢ëÁä∂ÊÄÅ:', videoTrack.enabled)
      }
    }
  }

  // ÂàáÊç¢Êâ¨Â£∞Âô®
  const toggleSpeaker = async () => {
    // Âú®ÁßªÂä®Á´ØÂèØ‰ª•ÂàáÊç¢Êâ¨Â£∞Âô®
    try {
      // ËøôÈáåÈúÄË¶ÅÊ†πÊçÆÂÖ∑‰ΩìÂπ≥Âè∞ÂÆûÁé∞
      console.log('üîä ÂàáÊç¢Êâ¨Â£∞Âô®')
    } catch (err) {
      console.error('ÂàáÊç¢Êâ¨Â£∞Âô®Â§±Ë¥•:', err)
    }
  }

  // Â±èÂπïÂÖ±‰∫´
  const startScreenShare = async () => {
    try {
      const screenStream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: true
      })

      if (peerConnection.value && localStream.value) {
        // ÊõøÊç¢ËßÜÈ¢ëËΩ®ÈÅì
        const videoTrack = screenStream.getVideoTracks()[0]
        const sender = peerConnection.value.getSenders().find(s => 
          s.track && s.track.kind === 'video'
        )

        if (sender) {
          await sender.replaceTrack(videoTrack)
        }

        if (currentCall.value) {
          currentCall.value.caller.isScreenSharing = true
          currentCall.value.type = 'screen'
        }

        // ÁõëÂê¨Â±èÂπïÂÖ±‰∫´ÁªìÊùü
        videoTrack.onended = () => {
          stopScreenShare()
        }

        console.log('üñ•Ô∏è ÂºÄÂßãÂ±èÂπïÂÖ±‰∫´')
      }

    } catch (err) {
      console.error('Â±èÂπïÂÖ±‰∫´Â§±Ë¥•:', err)
      error.value = 'Â±èÂπïÂÖ±‰∫´Â§±Ë¥•'
    }
  }

  // ÂÅúÊ≠¢Â±èÂπïÂÖ±‰∫´
  const stopScreenShare = async () => {
    try {
      if (peerConnection.value && localStream.value) {
        // ÊÅ¢Â§çÊëÑÂÉèÂ§¥
        const videoTrack = localStream.value.getVideoTracks()[0]
        const sender = peerConnection.value.getSenders().find(s => 
          s.track && s.track.kind === 'video'
        )

        if (sender && videoTrack) {
          await sender.replaceTrack(videoTrack)
        }

        if (currentCall.value) {
          currentCall.value.caller.isScreenSharing = false
          currentCall.value.type = 'video'
        }

        console.log('üñ•Ô∏è ÂÅúÊ≠¢Â±èÂπïÂÖ±‰∫´')
      }

    } catch (err) {
      console.error('ÂÅúÊ≠¢Â±èÂπïÂÖ±‰∫´Â§±Ë¥•:', err)
    }
  }

  // Ê∏ÖÁêÜËµÑÊ∫ê
  const cleanup = async () => {
    try {
      // ÂÖ≥Èó≠Â™í‰ΩìÊµÅ
      if (localStream.value) {
        localStream.value.getTracks().forEach(track => track.stop())
        localStream.value = null
      }

      if (remoteStream.value) {
        remoteStream.value.getTracks().forEach(track => track.stop())
        remoteStream.value = null
      }

      // ÂÖ≥Èó≠PeerConnection
      if (peerConnection.value) {
        peerConnection.value.close()
        peerConnection.value = null
      }

      error.value = null

    } catch (err) {
      console.error('Ê∏ÖÁêÜËµÑÊ∫êÂ§±Ë¥•:', err)
    }
  }

  // ËæÖÂä©ÂáΩÊï∞
  const updateConnectionStatus = (status: RTCPeerConnectionState) => {
    if (currentCall.value) {
      const connectionStatus = status === 'connected' ? 'connected' : 
                             status === 'failed' ? 'failed' : 'connecting'
      currentCall.value.caller.connectionStatus = connectionStatus
      currentCall.value.receiver.connectionStatus = connectionStatus
    }
  }

  const addToHistory = (call: CallSession) => {
    callHistory.value.unshift(call)
    // ‰øùÁïôÊúÄËøë100Êù°ËÆ∞ÂΩï
    if (callHistory.value.length > 100) {
      callHistory.value = callHistory.value.slice(0, 100)
    }
  }

  const sendCallInvitation = async (targetUserId: string, data: any) => {
    // ËøôÈáåÂ∫îËØ•ÈÄöËøáWebSocketÊàñÂÖ∂‰ªñÊñπÂºèÂèëÈÄÅ‰ø°‰ª§
    console.log('üì§ ÂèëÈÄÅÈÄöËØùÈÇÄËØ∑:', data)
    // Ê®°ÊãüÂèëÈÄÅ
    return Promise.resolve()
  }

  const sendSignalingMessage = async (data: any) => {
    // ËøôÈáåÂ∫îËØ•ÈÄöËøáWebSocketÂèëÈÄÅ‰ø°‰ª§Ê∂àÊÅØ
    console.log('üì§ ÂèëÈÄÅ‰ø°‰ª§Ê∂àÊÅØ:', data)
    // Ê®°ÊãüÂèëÈÄÅ
    return Promise.resolve()
  }

  return {
    // Áä∂ÊÄÅ
    currentCall,
    callHistory,
    devices,
    settings,
    localStream,
    remoteStream,
    isInitialized,
    error,

    // ËÆ°ÁÆóÂ±ûÊÄß
    isInCall,
    callDuration,
    isAudioCall,
    isVideoCall,
    isScreenShare,

    // ÊñπÊ≥ï
    initialize,
    getDevices,
    startCall,
    answerCall,
    rejectCall,
    endCall,
    toggleMute,
    toggleVideo,
    toggleSpeaker,
    startScreenShare,
    stopScreenShare,
    cleanup
  }
})
